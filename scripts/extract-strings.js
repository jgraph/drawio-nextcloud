#!/usr/bin/env node

/**
 * Extracts translatable strings from source files and writes them to l10n/source-strings.json.
 * Also checks existing translation files for missing strings.
 *
 * Usage: node scripts/extract-strings.js
 */

const fs = require('fs');
const path = require('path');

const ROOT = path.resolve(__dirname, '..');
const L10N_DIR = path.join(ROOT, 'l10n');
const OUTPUT_FILE = path.join(L10N_DIR, 'source-strings.json');

function findFiles(dir, extension) {
    const results = [];
    for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory()) {
            results.push(...findFiles(fullPath, extension));
        } else if (entry.name.endsWith(extension)) {
            results.push(fullPath);
        }
    }
    return results;
}

function extractFromJS(content) {
    const strings = new Set();

    // Match t('drawio', 'string') and t("drawio", "string")
    const pattern1 = /t\(\s*['"]drawio['"]\s*,\s*'((?:[^'\\]|\\.)*)'\s*\)/g;
    const pattern2 = /t\(\s*['"]drawio['"]\s*,\s*"((?:[^"\\]|\\.)*)"\s*\)/g;

    // Match t(OCA.DrawIO.AppName, 'string') and t(OCA.DrawIO.AppName, "string")
    const pattern3 = /t\(\s*OCA\.DrawIO\.AppName\s*,\s*'((?:[^'\\]|\\.)*)'\s*\)/g;
    const pattern4 = /t\(\s*OCA\.DrawIO\.AppName\s*,\s*"((?:[^"\\]|\\.)*)"\s*\)/g;

    for (const pattern of [pattern1, pattern2, pattern3, pattern4]) {
        let match;
        while ((match = pattern.exec(content)) !== null) {
            strings.add(match[1].replace(/\\'/g, "'").replace(/\\"/g, '"'));
        }
    }

    return strings;
}

function extractFromPHP(content) {
    const strings = new Set();

    // Match $l->t("string") and $l->t('string')
    const pattern1 = /\$l->t\(\s*"((?:[^"\\]|\\.)*)"\s*\)/g;
    const pattern2 = /\$l->t\(\s*'((?:[^'\\]|\\.)*)'\s*\)/g;

    // Match $this->trans->t("string") and $this->trans->t('string')
    const pattern3 = /\$this->trans->t\(\s*'((?:[^'\\]|\\.)*)'\s*\)/g;
    const pattern4 = /\$this->trans->t\(\s*"((?:[^"\\]|\\.)*)"\s*\)/g;

    for (const pattern of [pattern1, pattern2, pattern3, pattern4]) {
        let match;
        while ((match = pattern.exec(content)) !== null) {
            strings.add(match[1].replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/\\n/g, '\n'));
        }
    }

    return strings;
}

// Collect all strings
const allStrings = new Set();

// Scan JS source files
const jsFiles = findFiles(path.join(ROOT, 'src'), '.js');
for (const file of jsFiles) {
    const content = fs.readFileSync(file, 'utf8');
    for (const s of extractFromJS(content)) {
        allStrings.add(s);
    }
}

// Scan PHP templates
const templateFiles = findFiles(path.join(ROOT, 'templates'), '.php');
for (const file of templateFiles) {
    const content = fs.readFileSync(file, 'utf8');
    for (const s of extractFromPHP(content)) {
        allStrings.add(s);
    }
}

// Scan PHP lib files
const libFiles = findFiles(path.join(ROOT, 'lib'), '.php');
for (const file of libFiles) {
    const content = fs.readFileSync(file, 'utf8');
    for (const s of extractFromPHP(content)) {
        allStrings.add(s);
    }
}

const sortedStrings = [...allStrings].sort();

console.log('Found ' + sortedStrings.length + ' translatable strings:\n');
for (const s of sortedStrings) {
    console.log('  - ' + s);
}

// Write source-strings.json
const output = {
    _comment: 'Auto-generated by scripts/extract-strings.js. Do not edit manually.',
    strings: sortedStrings,
};
fs.writeFileSync(OUTPUT_FILE, JSON.stringify(output, null, 2) + '\n');
console.log('\nWritten to ' + path.relative(ROOT, OUTPUT_FILE));

// Check translation coverage
const jsonFiles = fs.readdirSync(L10N_DIR).filter(function(f) {
    return f.endsWith('.json') && f !== 'source-strings.json';
});

let missingCount = 0;
for (const jsonFile of jsonFiles) {
    const lang = jsonFile.replace('.json', '');
    const content = JSON.parse(fs.readFileSync(path.join(L10N_DIR, jsonFile), 'utf8'));
    const translations = content.translations || {};
    const missing = sortedStrings.filter(function(s) { return !(s in translations); });

    if (missing.length > 0) {
        missingCount++;
        if (missing.length > 10) {
            // Only warn about severely incomplete translations
            console.log('\n  ' + lang + ': missing ' + missing.length + '/' + sortedStrings.length + ' strings');
        }
    }
}

if (missingCount > 0) {
    console.log('\n' + missingCount + ' language(s) have missing translations (this is normal for community translations).');
}
